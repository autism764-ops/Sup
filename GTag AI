<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Feature World: Random Chaos Edition – 3-Finger Gorilla VR</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#000;color:#fff;font-family:Arial,Helvetica,sans-serif}
    #notify{position:absolute;top:10px;left:50%;transform:translateX(-50%);font-size:1.2em;pointer-events:none;opacity:0;transition:opacity .3s}
    #notify.show{opacity:1}
    #ui{position:absolute;bottom:10px;left:10px;display:flex;gap:8px;z-index:10}
    button{width:60px;height:60px;font-size:24px;border:none;background:#ffffff33;color:#fff;border-radius:50%;backdrop-filter:blur(4px)}
    #jumpBtn{position:absolute;bottom:10px;right:10px;width:80px;height:80px;font-size:28px;background:#00ff8833}
  </style>
</head>
<body>
<div id="notify"></div>
<div id="ui">
  <button id="up">↑</button>
  <button id="down">↓</button>
  <button id="left">←</button>
  <button id="right">→</button>
</div>
<button id="jumpBtn">Jump</button>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/webxr/VRButton.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

<script>
/* ---------- CONFIG ---------- */
const TERRAIN_SIZE = 120;
const TERRAIN_RES  = 64;
const PICKUP_COUNT = 40;
const MOVE_FORCE   = 14;
const JUMP_VEL     = 7;
const SPEED_MULT   = 1.8;
const SLOW_MULT    = 0.45;
const INVIS_TIME   = 4; // seconds
const FRICTION     = 4.0; // friction / damping strength (higher = quicker slow down)
const BOUNDARY_MARGIN = 1.0; // how far from edge the monkey is allowed

/* ---------- SETUP ---------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);
const camera = new THREE.PerspectiveCamera(80, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0,4,6);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.xr.enabled = true;
document.body.appendChild(renderer.domElement);
document.body.appendChild(VRButton.createButton(renderer));

/* ---------- LIGHT ---------- */
scene.add(new THREE.HemisphereLight(0x87CEEB, 0x3d2e1c, 0.9));
const sun = new THREE.DirectionalLight(0xffffff, 1.2);
sun.position.set(20,50,20);
scene.add(sun);

/* ---------- CLOUDS ---------- */
const cloudGeo = new THREE.SphereGeometry(1, 12, 8);
const cloudMat = new THREE.MeshStandardMaterial({color:0xffffff, roughness:1});
function makeCloud(x,y,z){
  const g = new THREE.Group();
  for(let i=0;i<6;i++){
    const m = new THREE.Mesh(cloudGeo, cloudMat);
    m.position.set(Math.random()*3-1.5, Math.random()*1, Math.random()*3-1.5);
    m.scale.setScalar(0.6 + Math.random()*0.7);
    g.add(m);
  }
  g.position.set(x,y,z);
  scene.add(g);
  return g;
}
const clouds = [];
for(let i=0;i<15;i++) clouds.push(makeCloud(Math.random()*80-40, 18 + Math.random()*6, Math.random()*80-40));

/* ---------- TERRAIN ---------- */
const terrainGeo = new THREE.PlaneGeometry(TERRAIN_SIZE, TERRAIN_SIZE, TERRAIN_RES, TERRAIN_RES);
terrainGeo.rotateX(-Math.PI/2);
const pos = terrainGeo.attributes.position;
for(let i=0;i<pos.count;i++){
  const x = pos.getX(i), z = pos.getZ(i);
  pos.setY(i, (Math.sin(x*0.2)+Math.cos(z*0.15))*1.5);
}
terrainGeo.computeVertexNormals();
const terrain = new THREE.Mesh(terrainGeo, new THREE.MeshStandardMaterial({color:0x4a7023, roughness:1}));
terrain.name = "ground";
scene.add(terrain);

/* ---------- 3-FINGER GORILLA ---------- */
const monkey = new THREE.Group();
const bodyMat = new THREE.MeshStandardMaterial({color:0x6b4f3a});
const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.6, 1.2, 8, 16), bodyMat);
body.rotation.z = -0.2;
monkey.add(body);
const head = new THREE.Mesh(new THREE.SphereGeometry(0.5,16,16), new THREE.MeshStandardMaterial({color:0x2ecc71}));
head.position.set(0,1.1,0);
monkey.add(head);
function makeHand(){
  const h = new THREE.Group();
  const palm = new THREE.Mesh(new THREE.BoxGeometry(0.3,0.12,0.5), bodyMat);
  h.add(palm);
  for(let i=0;i<3;i++){
    const f = new THREE.Mesh(new THREE.CapsuleGeometry(0.06,0.4,4,8), bodyMat);
    f.position.set((i-1)*0.12, -0.2, 0.1);
    f.rotation.x = -0.4;
    h.add(f);
  }
  return h;
}
const leftHand = makeHand();
const rightHand = makeHand();
leftHand.position.set(-0.9, 0.2, 0);
rightHand.position.set( 0.9, 0.2, 0);
monkey.add(leftHand, rightHand);
monkey.userData = {
  velocity: new THREE.Vector3(),
  onGround: false,
  speed: 1,
  invisible: false,
  speedTimeout: null,
  invisTimeout: null
};
scene.add(monkey);

/* ---------- PICK-UPS ---------- */
const pickUps = [];
const geomPool = [
  new THREE.BoxGeometry(0.6,0.6,0.6),
  new THREE.SphereGeometry(0.4,16,12),
  new THREE.TorusGeometry(0.35,0.15,8,16),
  new THREE.ConeGeometry(0.3,0.8,8)
];
const matPool = [
  new THREE.MeshStandardMaterial({color:0xff1744, emissive:0xff1744, emissiveIntensity:0.2}),
  new THREE.MeshStandardMaterial({color:0x00e676, emissive:0x00e676, emissiveIntensity:0.2}),
  new THREE.MeshStandardMaterial({color:0x18ffff, emissive:0x18ffff, emissiveIntensity:0.2}),
  new THREE.MeshStandardMaterial({color:0xffea00, emissive:0xffea00, emissiveIntensity:0.2})
];
for(let i=0;i<PICKUP_COUNT;i++){
  const g = geomPool[Math.floor(Math.random()*geomPool.length)];
  const m = matPool[Math.floor(Math.random()*matPool.length)];
  const mesh = new THREE.Mesh(g, m);
  mesh.position.set((Math.random()-0.5)*TERRAIN_SIZE*0.9, 1 + Math.random()*3, (Math.random()-0.5)*TERRAIN_SIZE*0.9);
  mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
  mesh.userData.type = ["speed","slow","invis"][Math.floor(Math.random()*3)];
  scene.add(mesh);
  pickUps.push(mesh);
}

/* ---------- NOTIFY ---------- */
function notify(msg){
  const box = document.getElementById('notify');
  box.textContent = msg;
  box.classList.add('show');
  clearTimeout(box._hideTimer);
  box._hideTimer = setTimeout(()=>box.classList.remove('show'), 1500);
}

/* ---------- INPUT ---------- */
const keys = { up:false, down:false, left:false, right:false, jump:false };
const upBtn = document.getElementById('up');
const downBtn = document.getElementById('down');
const leftBtn = document.getElementById('left');
const rightBtn = document.getElementById('right');
const jumpBtn = document.getElementById('jumpBtn');

upBtn.addEventListener('pointerdown', ()=>keys.up = true);    upBtn.addEventListener('pointerup',   ()=>keys.up = false);
downBtn.addEventListener('pointerdown', ()=>keys.down = true);downBtn.addEventListener('pointerup', ()=>keys.down = false);
leftBtn.addEventListener('pointerdown', ()=>keys.left = true);leftBtn.addEventListener('pointerup', ()=>keys.left = false);
rightBtn.addEventListener('pointerdown', ()=>keys.right = true);rightBtn.addEventListener('pointerup', ()=>keys.right = false);

// Jump: set true on press and reset on release (prevents sticky jump)
jumpBtn.addEventListener('pointerdown', ()=>{ keys.jump = true; });
jumpBtn.addEventListener('pointerup',   ()=>{ keys.jump = false; });

// Keyboard: WASD and Space jump
window.addEventListener('keydown', (e)=>{
  if(e.code === 'KeyW') keys.up = true;
  if(e.code === 'KeyS') keys.down = true;
  if(e.code === 'KeyA') keys.left = true;
  if(e.code === 'KeyD') keys.right = true;
  if(e.code === 'Space') keys.jump = true;
});
window.addEventListener('keyup', (e)=>{
  if(e.code === 'KeyW') keys.up = false;
  if(e.code === 'KeyS') keys.down = false;
  if(e.code === 'KeyA') keys.left = false;
  if(e.code === 'KeyD') keys.right = false;
  if(e.code === 'Space') keys.jump = false;
});

/* ---------- VR GORILLA LOCOMOTION ---------- */
let leftGrab = false, rightGrab = false;
const leftGrip  = new THREE.Vector3();
const rightGrip = new THREE.Vector3();
const tmpVecA = new THREE.Vector3();
const tmpVecB = new THREE.Vector3();

renderer.xr.addEventListener('sessionstart', ()=>{
  // nothing to do here specifically, we'll read controller objects each frame in updateGrips()
});

/* helper: safe read button pressed state */
function isButtonPressedFromController(con, index){
  const src = con.inputSource;
  if(!src || !src.gamepad || !src.gamepad.buttons) return false;
  const b = src.gamepad.buttons[index];
  return !!(b && b.pressed);
}

function updateGrips(){
  const controllers = [renderer.xr.getController(0), renderer.xr.getController(1)];
  controllers.forEach(con=>{
    if(!con) return;
    const src = con.inputSource;
    if(!src) return;
    const pressed = isButtonPressedFromController(con, 1); // "grip" often mapped to button 1
    con.getWorldPosition(tmpVecA);
    if(src.handedness === 'left'){
      if(!leftGrab && pressed) leftGrip.copy(tmpVecA);
      leftGrab = pressed;
      if(leftGrab){
        const delta = tmpVecB.subVectors(leftGrip, tmpVecA);
        monkey.userData.velocity.add(delta.multiplyScalar(1.8));
        leftGrip.copy(tmpVecA);
      }
    } else if(src.handedness === 'right'){
      if(!rightGrab && pressed) rightGrip.copy(tmpVecA);
      rightGrab = pressed;
      if(rightGrab){
        const delta = tmpVecB.subVectors(rightGrip, tmpVecA);
        monkey.userData.velocity.add(delta.multiplyScalar(1.8));
        rightGrip.copy(tmpVecA);
      }
    }
  });
}

/* ---------- COLLISION / PICK-UP ---------- */
const handWorldPos = new THREE.Vector3();
function checkPickUps(){
  const hands = [leftHand, rightHand];
  for(let i = pickUps.length - 1; i >= 0; i--){
    const p = pickUps[i];
    let collided = false;
    for(let hi = 0; hi < hands.length && !collided; hi++){
      hands[hi].getWorldPosition(handWorldPos);
      const pickupWorldPos = tmpVecA.setFromMatrixPosition(p.matrixWorld);
      if(handWorldPos.distanceTo(pickupWorldPos) < 0.7){
        collided = true;
        scene.remove(p);
        pickUps.splice(i, 1);

        switch(p.userData.type){
          case 'speed':
            if(monkey.userData.speedTimeout) clearTimeout(monkey.userData.speedTimeout);
            monkey.userData.speed = SPEED_MULT;
            notify("SPEED BOOST!");
            monkey.userData.speedTimeout = setTimeout(()=>{ monkey.userData.speed = 1; monkey.userData.speedTimeout = null; }, 4000);
            break;
          case 'slow':
            if(monkey.userData.speedTimeout) clearTimeout(monkey.userData.speedTimeout);
            monkey.userData.speed = SLOW_MULT;
            notify("SLOWED!");
            monkey.userData.speedTimeout = setTimeout(()=>{ monkey.userData.speed = 1; monkey.userData.speedTimeout = null; }, 4000);
            break;
          case 'invis':
            if(monkey.userData.invisTimeout) clearTimeout(monkey.userData.invisTimeout);
            monkey.userData.invisible = true;
            const hidden = [];
            monkey.traverse(child=>{
              if(child.isMesh && child.visible){
                child.visible = false;
                hidden.push(child);
              }
            });
            notify("INVISIBLE!");
            monkey.userData.invisTimeout = setTimeout(()=>{
              monkey.userData.invisible = false;
              hidden.forEach(m=>m.visible = true);
              monkey.userData.invisTimeout = null;
            }, INVIS_TIME * 1000);
            break;
        }
      }
    }
  }
}

/* ---------- GROUND RAYCAST ---------- */
const downRay = new THREE.Raycaster();
downRay.ray.direction.set(0,-1,0);

/* ---------- ANIMATE ---------- */
const clock = new THREE.Clock();
function animate(){
  const dt = clock.getDelta();
  updateGrips();

  /* non-VR movement (keyboard/buttons) */
  const inputForce = new THREE.Vector3();
  if(keys.up)    inputForce.z -= 1;
  if(keys.down)  inputForce.z += 1;
  if(keys.left)  inputForce.x -= 1;
  if(keys.right) inputForce.x += 1;
  if(inputForce.lengthSq() > 0) inputForce.normalize().multiplyScalar(MOVE_FORCE * monkey.userData.speed * dt);
  monkey.userData.velocity.add(inputForce);

  // Jump - single impulse only when onGround
  if(keys.jump && monkey.userData.onGround){
    monkey.userData.velocity.y = JUMP_VEL;
    monkey.userData.onGround = false;
    keys.jump = false;
  }

  /* gravity */
  monkey.userData.velocity.y -= 20 * dt;
  const deltaPos = monkey.userData.velocity.clone().multiplyScalar(dt);
  monkey.position.add(deltaPos);

  /* ground collision using raycast directly under the monkey for accurate terrain height */
  const origin = tmpVecA.copy(monkey.position);
  origin.y += 5;
  downRay.ray.origin.copy(origin);
  const intersects = downRay.intersectObject(terrain, false);
  if(intersects.length > 0){
    const groundY = intersects[0].point.y;
    const standY = groundY + 1.2;
    if(monkey.position.y <= standY){
      monkey.position.y = standY;
      monkey.userData.velocity.y = 0;
      monkey.userData.onGround = true;
    } else {
      monkey.userData.onGround = false;
    }
  } else {
    monkey.userData.onGround = false;
  }

  /* apply horizontal friction/damping so the monkey slows naturally */
  // exponential damping factor (stable independent of dt)
  const damping = Math.exp(-FRICTION * dt);
  monkey.userData.velocity.x *= damping;
  monkey.userData.velocity.z *= damping;
  // keep small values near zero to avoid residual drift
  if(Math.abs(monkey.userData.velocity.x) < 0.0005) monkey.userData.velocity.x = 0;
  if(Math.abs(monkey.userData.velocity.z) < 0.0005) monkey.userData.velocity.z = 0;

  /* boundary clamping - keep monkey within terrain */
  const half = TERRAIN_SIZE / 2;
  const bound = half - BOUNDARY_MARGIN;
  if(monkey.position.x > bound){
    monkey.position.x = bound;
    monkey.userData.velocity.x = 0;
  } else if(monkey.position.x < -bound){
    monkey.position.x = -bound;
    monkey.userData.velocity.x = 0;
  }
  if(monkey.position.z > bound){
    monkey.position.z = bound;
    monkey.userData.velocity.z = 0;
  } else if(monkey.position.z < -bound){
    monkey.position.z = -bound;
    monkey.userData.velocity.z = 0;
  }

  /* camera follow (non-VR) */
  if(!renderer.xr.isPresenting){
    camera.position.lerp(new THREE.Vector3(monkey.position.x, monkey.position.y + 3, monkey.position.z + 6), 0.05);
    camera.lookAt(monkey.position);
  }

  /* animate clouds */
  clouds.forEach(c=>{ c.position.x += dt*0.5; if(c.position.x > 60) c.position.x = -60; });

  /* spin pickups */
  for(let i=0;i<pickUps.length;i++){
    pickUps[i].rotation.y += dt;
  }

  checkPickUps();
  renderer.render(scene, camera);
}
renderer.setAnimationLoop(animate);

/* ---------- RESIZE ---------- */
window.addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
